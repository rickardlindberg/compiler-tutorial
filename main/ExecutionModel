main.ExecutionModel

![Pre code generation.]($ROOT/static/images/stage-pre-code-gen.png)

At this point we have a parser (StageParsing) that transforms the con source
code to a parse tree. Before we can transform the parse tree to C code, we need
to understand the execution model of the source program. We need to figure out
how to run con programs in C. This is probably the most difficult part in
writing this compiler.

## Function + Environment = Closure

Let's take a look at the example from StageParsing again:

    let ANSWER = 42

    let main = \() ->
        printAnswer exit

    let printAnswer = \(k) ->
        print ANSWER k

This time we're going to look at how `printAnswer` is actually executed.

The first thing we must figure out in order to execute `printAnswer` is what
`print` is. Since it's not defined inside the function `printAnswer` or in its
arguments, we need to look for it somewhere else. In the general case, a
function has to look up names that do not exist in the argument list.

We call the place where functions look up names an **environment**. An
environment contains mappings from names to values. There is also a special
environment, the global environment, that has mappings for all top level
definitions and built-in names. In the example above, the global environment
looks like this:

![The global environment.]($ROOT/static/images/global-env.png)

A function without an environment is (in most cases) useless. Most of the time
a function need to look up names in an environment. That is why all the
functions are stored together with an environment in the environment table. We
call a function + an environment a **closure**.

So when `printAnswer` looks up `print` in the global environment, it gets back
a closure where the built-in function `print` is bundled together with an
environment.

## TODO

Let's look at an example:

    let fac = \(n, k) ->
        facAccumulate n 1 k

    let facAccumulate = \(n, result, k) ->
        isZero n
            (\() -> k result)
            (\() ->
                minus n 1 \(newN) ->
                times n result \(newResult) ->
                facAccumulate newN newResult k)

Let's try to run this function with n = 3:

    fac 3 k             -->
    facAccumulate 3 1 k -->
    facAccumulate 2 3 k -->
    facAccumulate 1 6 k -->
    facAccumulate 0 6 k -->
    k 6

`facAccumulate` is obviously called multiple times

* environment model

## Continue

RuntimeSupport or CodeGeneration
