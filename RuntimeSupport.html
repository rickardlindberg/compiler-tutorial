<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>RuntimeSupport</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="./static/css/blueprint/screen.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="./static/css/blueprint/print.css" type="text/css" media="print">
    <!--[if lt IE 8]>
      <link rel="stylesheet" href="./static/css/blueprint/ie.css" type="text/css" media="screen, projection">
    <![endif]-->
    <link rel="stylesheet" href="./static/css/pygments/syntax.css" type="text/css">
    <link rel="stylesheet" href="./static/css/layout.css" type="text/css">
    <link rel="stylesheet" href="./static/css/colors.css" type="text/css">
    <script type="text/javascript" src="./static/js/graph.js"></script>
  </head>
  <body>
    <div class="container noshowgrid">
      <div class="span-20 prepend-2 append-2">
        <h1>RuntimeSupport</h1>
        <div class="figure">
<img src="./static/images/runtime.png" alt="C runtime." /><p class="caption">C runtime.</p>
</div>
<p>Now that we've figured out the <a href="ExecutionModel.html" title="ExecutionModel">ExecutionModel</a> of con, we need to implement a C library that compiled con programs can use.</p>
<h2 id="environment">Environment</h2>
<p>We concluded that the environment was a central part in the <a href="ExecutionModel.html" title="ExecutionModel">ExecutionModel</a>. Let's see how we can implement that in C. The basic struct looks like this:</p>
<pre><code>struct env {
    struct ref_count ref_count;
    int size;
    struct pair * pairs;
    struct env * parent;
};</code></pre>
<p><code>ref_count</code> has to do with garbage collection. Ignore that for now, and we will come back to it later. The last entry is a pointer to a parent environment. It is <code>NULL</code> for the global environment. The middle part is where we actually implement the environment table. We implement it as an array of pairs. A pair looks like this:</p>
<pre><code>struct pair {
    char * key;
    void * ref_countable;
};</code></pre>
<p>The key is a string and the value is a pointer to some value. The value must be something that can be garbage collected.</p>
<p>The methods we need to work with environments are</p>
<ul>
<li><code>Env create_env(Env parent);</code></li>
<li><code>void env_insert(Env env, char * key, void * ref_countable);</code></li>
<li><code>void * env_lookup(Env env, char * key);</code></li>
<li><code>void free_env(void * env);</code></li>
</ul>
<h2 id="arguments">Arguments</h2>
<p>Next we need a structure to hold arguments to functions. The struct looks like this:</p>
<pre><code>struct args {
    struct ref_count ref_count;
    int size;
    void ** args;
};</code></pre>
<p>Arguments are implemented as an array of void pointers. The void pointer must point to a value that can be garbage collected.</p>
<p>The methods we need to work with arguments are</p>
<ul>
<li><code>Args create_args(int size);</code></li>
<li><code>void args_set(Args args, int i, void * ref_countable);</code></li>
<li><code>void * args_get(Args args, int i);</code></li>
<li><code>void free_args(void * args);</code></li>
</ul>
<h2 id="values">Values</h2>
<p>The values we store in environments and arguments can be one of the following:</p>
<ul>
<li>Primitive value (only numbers in our case)</li>
<li>Closure (function + environment)</li>
</ul>
<p>Numbers look like this:</p>
<pre><code>struct number {
    struct ref_count ref_count;
    int value;
};</code></pre>
<p>And methods:</p>
<ul>
<li><code>Number const_number(int i);</code></li>
<li><code>void free_number(void * number);</code></li>
</ul>
<p>Closures look like this:</p>
<pre><code>struct closure {
    struct ref_count ref_count;
    FnSpec fn_spec;
    Env env;
};</code></pre>
<p>And methods:</p>
<ul>
<li><code>Closure create_closure(FnSpec fn_spec, Env env);</code></li>
<li><code>void free_closure(void * closure);</code></li>
</ul>
<p><code>FnSpec</code> is the function without an environment. It is a pointer to a C function with the following type:</p>
<pre><code>Call aFunction(Env env, Args args);</code></pre>
<p>So all functions in con are translated to C functions with the above type. The input is the environment in which to execute this function and the arguments passed to it. The return value is a call which is simply a closure bundled together with arguments:</p>
<pre><code>struct call {
    struct ref_count ref_count;
    Closure closure;
    Args args;
};</code></pre>
<h2 id="a-call">A call</h2>
<p>Let's see if we can use the runtime to implement a call to a function. Assume we have the following body:</p>
<pre><code>add 2 5 handle_add_result</code></pre>
<p>First we need to have the global environment:</p>
<pre><code>Env env = create_env(NULL);
env_insert(&quot;handle_add_result&quot;, create_closure(generated_fn_1, env));
env_insert(&quot;add&quot;,               create_closure(builtin_add, env));</code></pre>
<p>Then we need the closure for <code>add</code>:</p>
<pre><code>Closure closure = (Closure)env_lookup(env, &quot;add&quot;);</code></pre>
<p>Then we need to create the arguments for the call:</p>
<pre><code>Args args = create_args(3);
args_set(0, create_number(2));
args_set(1, create_number(5));
args_set(2, env_lookup(env, &quot;handle_add_result&quot;));</code></pre>
<p>Then we need to bundle it in a <code>Call</code>:</p>
<pre><code>Call call = create_call(closure, args);</code></pre>
<p>We can then call it like this:</p>
<pre><code>next_call = call-&gt;closure-&gt;fn_spec(call-&gt;closure-&gt;env, call-&gt;args);</code></pre>
<h2 id="garbage-collection">Garbage collection</h2>
<p>Every time we create a new object using a <code>create_</code> function, new memory is allocated dynamically. This memory must be freed or we will eventually run out of memory.</p>
<p>The problem is that we can't always know when objects can be freed. Consider the <code>add3</code> example:</p>
<pre><code>let add3 = \(one, two, three, k) -&gt;
    add one two (\(sum) -&gt;
        add sum three k
    )</code></pre>
<p>This will result in two C functions: one for <code>add3</code> and one for the anonymous function. When <code>add3</code> is called, we have allocated memory to hold <code>k</code>. But we can't free the memory for <code>k</code> when we leave the C function for <code>add3</code> because it is needed later by the anonymous function.</p>
<p>We solve this problem by using reference counting. So all structs that we allocated must have a reference counter as first entry:</p>
<pre><code>struct ref_count ref_count;</code></pre>
<p>That struct looks like this:</p>
<pre><code>struct ref_count {
    int count;
    FnFree free_fn;
};</code></pre>
<p>It keeps track of how many things are referencing this object and also has a pointer to a function to free this object. Different objects are freed in different ways, so we need a free function for each object we allocate.</p>
<p>Let's look at how freeing arguments work:</p>
<pre><code>void free_args(void * ref_countable) {
    Args args = (Args)ref_countable;
    int i;
    for (i = 0; i &lt; args-&gt;size; i++) {
        dec_and_free(args-&gt;args[i]);
    }
    free(args-&gt;args);
    free(args);
}</code></pre>
<p>The for loop goes over all arguments and calls <code>dec_and_free</code> on each one of them. In the above example that includes calling <code>dec_and_free</code> on <code>k</code>. What happens is that the reference counter is decreased by one, saying that this arguments structure no longer holds a reference to <code>k</code>. But freeing is only performed if the reference count is 0. Since <code>k</code> has been put in a new environment for use by the anonymous function later, it will not be freed when freeing the arguments since that new environment has a reference to <code>k</code>.</p>
<p>The last part of <code>free_args</code> frees the array allocated for the arguments and the arguments structure itself.</p>
<h2 id="continue">Continue</h2>
<p><a href="CodeGeneration.html" title="CodeGeneration">CodeGeneration</a></p>
        <hr />
        <svg xmlns="http://www.w3.org/2000/svg" id="canvas"></svg>
        <script type="text/javascript">
            var colors = function (level) {
                if (level == 1) {
                    return {
                        color: "#fcaf3e",
                        stroke: "#ab7423"
                    };
                } else if (level == 2) {
                    return {
                        color: "#fce94f",
                        stroke: "#c4a000"
                    };
                } else if (level == 3) {
                    return {
                        color: "#8ae234",
                        stroke: "#425d26"
                    };
                }
            };
            var goToPageFn = function(page) {
                return function() {
                    location.href = page + ".html";
                };
            };
            var g = new Graph("canvas", 800, 400);
            g.repulsion = g.repulsion / 2;
            //g.spring_length = 8;
            g.setCenter("RuntimeSupport");
            g.createVertex("RuntimeSupport", colors(1), goToPageFn("RuntimeSupport"));g.createVertex("AssembleHex", colors(2), goToPageFn("AssembleHex"));g.createVertex("CodeGeneration", colors(2), goToPageFn("CodeGeneration"));g.createVertex("ExecutionModel", colors(2), goToPageFn("ExecutionModel"));g.createVertex("CodeGenerationFramework", colors(3), goToPageFn("CodeGenerationFramework"));g.createVertex("MovingForward", colors(3), goToPageFn("MovingForward"));g.createVertex("StageParsing", colors(3), goToPageFn("StageParsing"));
            g.createEdge("RuntimeSupport", "CodeGeneration");g.createEdge("RuntimeSupport", "ExecutionModel");g.createEdge("AssembleHex", "CodeGeneration");g.createEdge("AssembleHex", "MovingForward");g.createEdge("AssembleHex", "RuntimeSupport");g.createEdge("CodeGeneration", "AssembleHex");g.createEdge("CodeGeneration", "CodeGenerationFramework");g.createEdge("CodeGeneration", "RuntimeSupport");g.createEdge("ExecutionModel", "RuntimeSupport");g.createEdge("ExecutionModel", "StageParsing");g.createEdge("CodeGenerationFramework", "CodeGeneration");g.createEdge("StageParsing", "ExecutionModel");
            g.go();
        </script>
        <hr />
        <p>
        <center>
        1. <a href="HomePage.html">HomePage</a>
        |
        2. <a href="StageParsing.html">StageParsing</a>
        |
        3. <a href="RuntimeSupport.html">RuntimeSupport</a>
        |
        4. <a href="CodeGeneration.html">CodeGeneration</a>
        |
        5. <a href="AssembleHex.html">AssembleHex</a>
        |
        6. <a href="MovingForward.html">MovingForward</a>
        </center>
        </p>
        <hr />

        <div id="disqus_thread"></div>
        <script type="text/javascript">
        var disqus_shortname = 'compilertutorial';
        (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        <hr />
      </div>
    </div>
  </body>
</html>